{"name": "democode_data_manipulation", "extension": ".R", "course": "RB", "st_mode": 33204, "st_ino": 13091679, "st_dev": 16777233, "st_nlink": 1, "st_uid": 501, "st_gid": 20, "st_size": 7109, "st_atime": 1759510074.2045412, "st_mtime": 1759492208.0, "st_ctime": 1759510073.3688414, "st_birthtime": 1759492208.0, "st_blocks": 16, "st_blksize": 4096, "content": "## DEMOCODE for the DATA MANIPULATION part of the R BOOTCAMP\n\n#### Setup ####\n## include necessary packages\nrequire(dplyr)\nrequire(tidyr)\n\n\n#### Dataset ####\n## load data and inspection\ndata(diamonds, package = \"ggplot2\")\nhead(diamonds)\ndim(diamonds)\n\n\n\n#### Long and wide format ####\n## this is a dataset in long format\ndata.frame(Name = rep(c(\"Max\", \"Steve\", \"Hannah\"), each = 2),\n           Day = rep(c(\"Monday\", \"Tuesday\"), 3),\n           coffees = c(1, 0, 2, 1, 1, 2))\n\n\n## this is a dataset in wide format\ndata.frame(Name = c(\"Max\", \"Steve\", \"Hannah\"),\n           coffee.monday = c(1, 2, 1),\n           coffee.tuesday = c(0, 1, 2))\n\n## converting wide to long\ndiamonds$ID <- 1:nrow(diamonds)\ndiamonds.long.format <- \n  pivot_longer(diamonds,\n               cols = -c(ID, cut, color, clarity),\n               names_to = \"feature\",\n               values_to = \"value\")\n\n## or long to wide\npivot_wider(diamonds.long.format,\n            names_from = \"feature\", \n            values_from = \"value\")\n\n## this works too in this case:\n# pivot_wider(diamonds.long.format,\n#             names_from = feature, values_from = value)\n\n\n#### The package dplyr ####\n\n## data sets classes\nclass(diamonds)\nhead(as.data.frame(diamonds))\nprint(diamonds, width = 70)\n\n\n#### Data manipulation ####\n\n## select only specific columns: these produce the same output, for this dataset\nselect(diamonds, x, y, z)\ndiamonds[ , c(\"x\", \"y\", \"z\")]\ndiamonds[ , colnames(diamonds) ==\"x\"| colnames(diamonds) ==\"y\"]\n\n## drop a column\nselect(diamonds, -ID)\n\n\n## select columns using characters or regular expressions\nselect(diamonds, contains(\"ce\"))\nselect(diamonds, matches(\"c.\"))\nselect(diamonds, matches(\".c.\"))\n\n## filter according to some condition\nfilter(diamonds, `carat` > 4, `cut` == \"Fair\")\n## note: use \"autocomplete\" (i.e.: Tab key) to get the backticks. This is\n## useful when your column names contain spaces\n\n## create or calculate new columns\nmutate(diamonds, xPLUSy = x + y, depth.check = 2 * z / (xPLUSy))\n\n## summarise or aggregate\nsummarise(diamonds, \n          mean.carat = mean(carat), \n          mean.price = mean(price),\n          median.carat = median(carat), \n          median.price = median(price))\n\n## create or calculate new columns for *each* of the variables/columns\nmutate(diamonds, across(-c(cut, color, clarity), .fns = cumsum))\n\n## summarise or aggregate *each* of the variables/columns\nsummarise(diamonds,\n          across(-c(cut, color, clarity),\n                 .fns = list(mean = ~ mean(.x, na.rm = TRUE),\n                             sum = ~ sum(.x, na.rm = TRUE))))\n\n\n### The pipe operator ###\n\n## makes it easy to read code: read from left to right\n## try the short-cut: Ctrl + Shift + M\n# x %>% f(y)          ## f(x, y)\n# z %>% f(x, y, .)    ## f(x, y, z)\n\n\n## alternative using select\ndiamonds %>%\n  select(x, y, z)\n\n## alternative using filter\ndiamonds %>% \n  filter(`carat` > 4, `cut` == \"Fair\")\n\n## alternative using mutate\ndiamonds %>%\n  mutate(xPLUSy = x + y, depth.check = 2 * z / (xPLUSy))\n\n## alternative using summarise across\ndiamonds %>%\n  summarise(across(-c(cut, color, clarity),\n                   .fns = list(mean = ~ mean(.x, na.rm = TRUE),\n                               sum = ~ sum(.x, na.rm = TRUE))))\n\n\n### Group data ###\ndiamonds %>% \n  group_by(cut) %>% \n  print(n = 4, width = 60)\n\n## mutate separately over a group of data\ndiamonds %>%\n  group_by(cut) %>%\n  mutate(mean.price.g = mean(price))\n\n# diamonds %>%\n#   mutate(mean.price.g = mean(price))\n\n\ndiamonds %>%\n  group_by(cut) %>%\n  mutate(pmax.x.y.MAXz = pmax(x, y, max(z))) ## pmax gives pairwise maximum\n\n\n## summarise separately over a group of data\ndiamonds %>% \n  group_by(cut) %>% \n  summarise(mean.carat = mean(carat),\n            mean.price = mean(price),\n            median.carat = median(carat),\n            median.price = median(price))\n\n## alternatives\n## use apply-family in R\ntapply(diamonds$price, diamonds$cut, mean)\n\n## use by from base R\nby(diamonds[, -c(2:4)], diamonds[, \"cut\"], summary)\n\n## use aggregate from base R\naggregate(cbind(price, carat) ~ cut, data = diamonds, FUN = mean)\n\n## same as\n# aggregate(. ~ cut, data = diamonds,\n#           FUN = mean)[, c(\"cut\", \"price\", \"carat\")]\n\n## do... over a group of data\n## fit two regression lines per group\n\n# model mod.1: price = carat\n# model mod.2: price = carat + carat^2\nfit.lm.group <- do(.data = diamonds %>% group_by(cut),\n                   mod.1 = lm(price ~ carat, data = .),\n                   mod.2 = lm(price ~ poly(carat, 2), data = .))\n\n## extract R^2 value\nsummarise(.data = fit.lm.group,\n          Rsqr.m1 = summary(mod.1)$r.squared,\n          Rsqr.m2 = summary(mod.2)$r.squared)\n\n## compare both models using ANOVA\ndo(.data = fit.lm.group, anova = anova(.$mod.1, .$mod.2))[[1]]\n\n\n\n## ungroup data: general syntax\n# diamonds %>%\n#   group_by(cut) %>%\n#   ... %>%  ## substitute this line by something meaningful\n#   ungroup()\n\ndiamonds %>%\n  select(-color, -clarity) %>%\n  group_by(cut) %>%\n  summarise(across(.fns = list(mean = ~ mean(.x),\n                               median = ~ median(.x)))) %>%\n  ungroup()\n\n\n## here a few examples of wrong syntax\n# diamonds %>%\n#   select(-color, -clarity) %>%\n#   group_by(cut) %>%\n#   summarise(across(.fns = ~ mean))\n# \n## does not produce new columns\n# diamonds %>%\n#   select(-color, -clarity) %>%\n#   group_by(cut) %>%\n#   summarise(across(.fns = mean))\n# \n# diamonds %>%\n#   select(-color, -clarity) %>%\n#   group_by(cut) %>%\n#   summarise(across(.fns = ~ mean(.x)))\n# \n## you really need list and .x\n# diamonds %>%\n#   select(-color, -clarity) %>%\n#   group_by(cut) %>%\n#   summarise(across(.fns = list(mean = ~ mean(.x))))\n\n\n### Join or combine data sets\n\ndata.A <- data.frame(name = c(\"Anna\", \"Jessie\", \"Markus\"),\n                     nr.of.pets = c(2, 1, 2))\ndata.A\n\ndata.B <- data.frame(name = c(\"Anna\", \"Jessie\", \"Petra\"),\n                     favorite.food = c(\"rice\", \"pasta\", \"sushi\"))\ndata.B\n\n## return all observations from x and y which could be matched to x\nleft_join(x = data.A, y = data.B, by = \"name\")\n\n\n## return all observations from y and x which could be matched to y\nright_join(x = data.A, y = data.B, by = \"name\")\n## equivalent to\nleft_join(x = data.B, y = data.A, by = \"name\")\n\n## return all observations which could be matched in both data sets\ninner_join(x = data.A, y = data.B, by = \"name\")\n\n\n## return all observations from x and y\nfull_join(x = data.A, y = data.B, by = \"name\")\n\n## example with different column names\ndata.A1 <- data.frame(Name = c(\"Anna\", \"Jessie\", \"Markus\"),\n                      nr.of.pets = c(2, 1, 2))\ndata.A1\n\nleft_join(x = data.B, y = data.A1, by = c(\"name\" = \"Name\"))\nright_join(x = data.B, y = data.A1, by = c(\"name\" = \"Name\"))\n\n\n## alternative, using the merge function from the base R package\n## left join\nmerge(x = data.A, y = data.B, by = \"name\",\n      all.x = TRUE, all.y = FALSE)\n\n## right join\nmerge(x = data.A, y = data.B, by = \"name\",\n      all.x = FALSE, all.y = TRUE)\n\n## inner join\nmerge(x = data.A, y = data.B, by = \"name\") ## default: all = FALSE\n\n## full join\nmerge(x = data.A, y = data.B, by = \"name\", all = TRUE)\n\n"}